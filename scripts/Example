#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""Functions:
      1. Parse HML sequences
      2. Match the correct HLA typing GL strings
      3. Sequence alignment to IMGT/HLA reference sequences
      4. Annoatate - Extract Exon/Intron.
"""
#from os import walk, environ
from Bio import SeqIO, AlignIO
import re   # regular expression
# from subprocess import Popen, PIPE, STDOUT
# from os.path import join, abspath, dirname, split


__author__ = "Hu Huang"
__copyright__ = "Copyright 2017, Hu Huang"
__credits__ = ["Add names"]
__license__ = "GPL"
__version__ = "0.1-dev"
__maintainer__ = "Hu Huang"
__email__ = "hwangtiger@gmail.com"


IMGT_db_fp = "../IMGTHLA/" 

with open(IMGT_db_fp+"/fasta/A_gen.fasta") as input_handle:
    for record in SeqIO.parse(input_handle, "fasta"):
        print(record.id)
 
IMGT_aligned_seqs = open(IMGT_db_fp + "/alignments/A_gen.txt", "r")
print IMGT_aligned_seqs.readlines(5)

##
aligned_seqs = AlignIO.parse(IMGT_db_fp + "/alignments/A_gen.txt", "clustal")
for seqs in aligned_seqs:
    print(len(seqs))
    print("")
##    

filename = IMGT_db_fp + "/alignments/A_gen.txt"

####### test module
HLAtyping = 'A*01:01:01:01'              ## HLA typing
patt = re.compile(re.escape(HLAtyping))  ## pattern - find HLA typing
fiIn = open(filename, "r").readlines()


ll = "A*01:01:01:01     CAGGAGCAGA GGGGTCAGGG CGAAGTCCCA GGGCCCCAGG CGTGGCTCTC AGGGTCTCAG GCCCCGAAGG CGGTGTATGG ATTGGGGAGT CCCAGCCTTG "

ll2 = re.sub(re.escape(HLAtyping), "", ll)
ll3 = re.sub(" ", "", ll2)
## ll3 += ll2  # dummy


re.match('A*01:01:01:01', ll)
re.match('A*01:01:01:01', patt)

re.findall(re.escape('A*01:01:01:01'), ll)


if re.match(HLAtyping, ll): 
    print("yes")

if HLAtyping in ll:
    print("Yes")

re.search(re.escape('A*01:01:01:01'), ll).start

#######  read alignement line
LL = ""
for lines in fiIn:
    if HLAtyping in patt.findall(lines):
        LL += re.sub(" ", "", re.sub(re.escape(HLAtyping), "", lines.rstrip()))
LL2 = re.sub("\.", "-", LL)

LL2.find()

aligned_lines = re.split("\n+", fiIn)

ab = [re.split(" ", entry, 3) for entry in aligned_lines[8:11]]

### Parse sequence file
my_seq = SeqIO.parse("../Fasta_from_HML/1.0.1a_NGS1-1_HML_Haploid_Merged.fasta", "fasta")

seqs = SeqIO.read("../Fasta_from_HML/1.0.1a_NGS1-1_HML_Haploid_Merged.fasta", "fasta")

identifiers = [seq_record.id for seq_record in SeqIO.parse("../Fasta_from_HML/1.0.1a_NGS1-1_HML_Haploid_Merged.fasta", "fasta")]

records = list(SeqIO.parse("../Fasta_from_HML/1.0.1a_NGS1-1_HML_Haploid_Merged.fasta", "fasta"))
print("Found %i records" % len(records))

record_iterator = SeqIO.parse("../Fasta_from_HML/1.0.1a_NGS1-1_HML_Haploid_Merged.fasta", "fasta")
first_record = next(record_iterator)
print(first_record)

def get_accession(record):
    """"Given a SeqRecord, return the accession number as a string.
    e.g. "gi|2765613|emb|Z78488.1|PTZ78488" -> "Z78488.1"
    """
    parts = record.id.split("|")
    assert len(parts) == 5 and parts[0] == "gi" and parts[2] == "emb"
    return parts[3]


#####################
# read line by line
###################
# try seek
# or
for line in open(data.txt) print(line)

with open("filename.txt") as f:
    for line in f:
        if "Smith" in line:
             print line
### Use Dictionary
example_dict = {'A*01:01:01:01': {'unaligned':'CAGGAGCAGA GGGGTCAGGG CGAAGTCCCA GGGCCCCAGG CGTGGCTCTC AGGGTCTCAG GCCCCGAAGG CGGTGTATGG ATTGGGGAGT CCCAGCCTTG', 'alignedGenomic':'GGGATTCCCC AACTCCGCAG TTTCTTTTCT', 'alignedCDS':'CCCTCTCCCA ACCTACGTAG GGTCCTTCAT CCTGGATACT CACGACGCGG ACCCAGTTCT CACTCCCATT'}, 
                    'A*01:01:01:02': {'unaligned':'qqwwewew','alignedGenomic':'ffffffffffffffffff','alignedCDS':'fffffffffffffdddddddd'}}

### Making a dictionary ###

data = {}
# OR
data = dict()

### Initially adding values ###

data = {'a':1,'b':2,'c':3}
# OR
data = dict(a=1, b=2, c=3)

### Inserting/Updating value ###

data['a']=1  # updates if 'a' exists, else adds 'a'
# OR
data.update({'a':1})
# OR
data.update(dict(a=1))
# OR
data.update(a=1)

### Merging 2 dictionaries ###

data.update(data2)  # Where data2 is also a dict.

### Deleting items in dictionary ###

del data[key] #Remove specific element in a dictionary
data.pop(key) #Removes the key & returns the value
data.clear() #Clear entire dictionary

############# dumped lines
 filename = IMGT_db_fp + "/alignments/A_gen.txt"
    # Read alignment file
    alignment_lines = open(filename).readlines() ### open(filename, 'r')
#    r = re.compile(".*"+seqType)
    
#    aa = filter(r.match, alignment_lines)
    
    seqLineIndex = [Line+2 for Line, word in enumerate(alignment_lines) if re.search(seqType, word)]
    
#    alignment_block = open(filename).read()
#    ab = [mLine.span() for mLine in re.finditer(r, alignment_block)]

#    HLAtypings = []
#    Alignment_seqs = []

    # alignment_list = csv.reader(open(filename, "r"), delimiter = " " )
    
    # alignment_list = open(filename).readlines() ### open(filename, 'r')
    # alignment_file.readline()
    
## build a dictionary structure
    d = {}

    for key in set(gDNA_alignment.keys() + CDS_alignment.keys()):
        try:
            d.setdefault(key,[]).append(gDNA_alignment[key])        
        except KeyError:
            pass
            
        try:
            d.setdefault(key,[]).append(CDS_alignment[key])          
        except KeyError:
            pass

    print d
    
    
#### read and write csv
### Here are some minimal complete examples how to read CSV files and how to write CSV files with Python.

## Python 2+3: Reading a CSV file

### Pure Python

# -*- coding: utf-8 -*-
import csv

# Define data
data = [(1, "A towel,", 1.0),
        (42, " it says, ", 2.0),
        (1337, "is about the most ", -1),
        (0, "massively useful thing ", 123),
        (-2, "an interstellar hitchhiker can have.", 3)]

# Write CSV file
with open('test.csv', 'w') as fp:
    writer = csv.writer(fp, delimiter=',')
    # writer.writerow(["your", "header", "foo"])  # write header
    writer.writerows(data)

# Read CSV file
with open('test.csv', 'r') as fp:
    reader = csv.reader(fp, delimiter=',', quotechar='"')
    # next(reader, None)  # skip the headers
    data_read = [row for row in reader]

print(data_read)

######## 

####### Read and write JSON
### Read and write JSON files with Python 2+3; works with unicode

# -*- coding: utf-8 -*-
import json

# Make it work for Python 2+3 and with Unicode
import io
try:
    to_unicode = unicode
except NameError:
    to_unicode = str

# Define data
data = {'a list': [1, 42, 3.141, 1337, 'help', u'â‚¬'],
        'a string': 'bla',
        'another dict': {'foo': 'bar',
                         'key': 'value',
                         'the answer': 42}}

# Write JSON file
with io.open('data.json', 'w', encoding='utf8') as outfile:
    str_ = json.dumps(data,
                      indent=4, sort_keys=True,
                      separators=(',', ': '), ensure_ascii=False)
    outfile.write(to_unicode(str_))

# Read JSON file
with open('data.json') as data_file:
    data_loaded = json.load(data_file)

print(data == data_loaded)

########
## These functions are all that you need for saving and loading almost any object:

def save_obj(obj, name ):
    with open('obj/'+ name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)

def load_obj(name ):
    with open('obj/' + name + '.pkl', 'rb') as f:
        return pickle.load(f)